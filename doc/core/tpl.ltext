Template Engine
===============

The octris framework provides an own template engine, which works independet of the structure of a template. It does
not matter, if the template is a simple text file or in HTML or XML format. 

The template engine converts templates to cacheable PHP code.


Template element syntax
-----------------------

Elements to be parsed by the template engine, have to be enclosed inside of {{...}}.

Template variables
------------------

Template variables are written in the form the following example, where ~varname~ is a fully
qualified name of an existing template variable:

..  source: html

    {{$varname}}
    {{$varname:first}}
    {{$varname:0:second}}
    ...

The examples above shows the access to values of simple variables and multidimensional arrays:

..  source: php

    $varname
    $varname["first"]
    $varname["0"]["second"]

_Example:_

..  source: html

    <html>
        <head>
            <title>{{$title}}</title>
        </head>

        <body>
            <p>
                <b>Hello {{$name:name}} {{$name:surname}}</b>
            </p>
            
            <p>
                Please <a href="{{$url}}">click</a> here!
            </p>
        </body>
    </html>

Template Constants
------------------

Template constants are written in the form the following example, where ~CONSTANT~ is a fully
qualified name of an existing template constant:

..  source: html

    {{%CONSTANT}}

The template engine defines the following constants:

Template block commands
-----------------------

A block encloses a part of a template and executes different actions of the enclosed template part:

..  source: html

    {{#block( parameter )}}
    ...
    {{#end}}

The template engine supports the following block commands:

#copy
~~~~~

This command copies a part of the template into an internal buffer. The command may be used to prevent duplicate
re-building of complex template parts. A HTML page navigation which should be displayed at the top and at the
bottom of the page, can be build the first time, copied and inserted as complete build snippet instead of 
re-building it at the bottom of the page. The copied template part may be accessed like a normal template variable.

_Copy block:_

..  source: html

    {{#copy($buffer)}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $buffer       | mixed     | x         | buffer variable to store copied content in    |
+---------------+-----------+-----------+-----------------------------------------------+

_Paste block:_

..  source: html

    {{$name}}

#cron
~~~~~

Publish a template part based on time.

..  source: html

    {{#cron($start [, $end])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $start        | mixed     | x         | start time as date/time string or unix        |
|               |           |           | timestamp                                     |
+---------------+-----------+-----------+-----------------------------------------------+
| $end          | mixed     | -         | optional end time as date/time string or unix |
|               |           |           | timestamp                                     |
+---------------+-----------+-----------+-----------------------------------------------+

The ~$end~ parameter is optional. If it's not specified, the block will never be hidden again. 
Note, that this is just triggered on server side. The block will only be displayed/hidden on a 
new request.

#cut
~~~~

The ~#cut~ block command is similar to ~#copy~, expect, that it cut's the rendered block into the buffer. The command
is useful to post-process rendered template parts. for example: a build stylesheet may be cut, compressed by a css-
compressor and than output in the template.

_Cut block:_

..  source: html

    {{#cut($buffer)}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $buffer       | mixed     | x         | buffer variable to store cut content in       |
+---------------+-----------+-----------+-----------------------------------------------+

_Process (and paste) block (example):_

..  source: html

    {{compactCSS($name)}}


#foreach
~~~~~~~~

This block command implements an array iterator. The enclosed block will be 
repeated for each element of the array specified as parameter. For each 
iteration a template variable of the specified name will be filled with the 
contents of the array item of the iteration.

..  source: html

    {{#foreach($item, $array [, $meta])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $item         | mixed     | x         | variable to store array item in               |
+---------------+-----------+-----------+-----------------------------------------------+
| $array        | array     | x         | array to iterate                              |
+---------------+-----------+-----------+-----------------------------------------------+
| $meta         | array     | -         | optional variable for metainformation         |
+---------------+-----------+-----------+-----------------------------------------------+

_Meta information:_

~#foreach~ adds the following keys/values to the optional ~$meta~ variable:

+---------------+-----------------------------------------------------------+
| Name          | Description                                               |
+===============+===========================================================+
| is_first      | is true, if it's the first iteration step                 |
+----------------+----------------------------------------------------------+
| is_last       | is true, if it's the last iteration step                  |
+---------------+-----------------------------------------------------------+
| key           | contents of key of iterartion step                        |
+---------------+-----------------------------------------------------------+
| pos           | number of iteration step starting with 0                  |
+---------------+-----------------------------------------------------------+
| count         | total number of items in array                            |
+---------------+-----------------------------------------------------------+

To access the properties in a template, just specify a third parameter, a variable
for the ~#foreach~ block:

..  source: html

    {{#foreach($item, $array, $meta)}}
        {{#if($meta:is_first)}}
            ...
        {{#end}}
    {{#end}}

#loop
~~~~~

Loop over the enclosed template block.

..  source: html

    {{#loop($step, $from, $to [, $meta])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $step         | int       | x         | current step of the loop                      |
+---------------+-----------+-----------+-----------------------------------------------+
| $from         | int       | x         | starting point of loop                        |
+---------------+-----------+-----------+-----------------------------------------------+
| $to           | int       | x         | ending point of loop                          |
+---------------+-----------+-----------+-----------------------------------------------+
| $meta         | array     | -         | optional variable for metainformation         |
+---------------+-----------+-----------+-----------------------------------------------+

It's allowed to specify ~from~ with a bigger number than ~to~.

_Meta information:_

~#loop~ adds the following keys/values to the optional ~$meta~ variable:

+---------------+-----------------------------------------------------------+
| Name          | Description                                               |
+===============+===========================================================+
| is_first      | is true, if it's the first iteration step                 |
+----------------+----------------------------------------------------------+
| is_last       | is true, if it's the last iteration step                  |
+---------------+-----------------------------------------------------------+
| key           | number of iteration step starting with 0                  |
+---------------+-----------------------------------------------------------+
| pos           | number of iteration step starting with 0                  |
+---------------+-----------------------------------------------------------+
| count         | total number of items in array                            |
+---------------+-----------------------------------------------------------+

~pos~ and ~key~ contain the same values. ~key~ is provided, to return the same meta
information for both iteration block types ~#foreach~ and ~#loop~.

To access the properties in a template, just specify a third parameter, a variable
for the ~#loop~ block:


..  source: html

    {{#loop($i, 0, 5, $meta)}}
        {{if($meta:is_first)}}
            ...
        {{#end}}
    {{#end}}

#onchange
~~~~~~~~~

This command is normally used inside of a block, wich is repeated by commands 
like ~#foreach~ and ~#loop~. With this command it's possible to observe the value
of a template variable. If the variable changes between _two_ calls of 
~#onchange~, the enclosed block will be executed.

..  source: html

    {{#onchange($value)}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $value        | mixed     | x         | variable to observe                           |
+---------------+-----------+-----------+-----------------------------------------------+

_Example:_

The example below demonstrates, how the variable ~$step~ is observed. If ~$step~
changes it's value, the enclosed block will be executed.

..  source: html

    {{#loop($step, 0, 5)}}
        ...
        {{#onchange($step)}}
            changed
        {{#end}}
    {{#end}}

#trigger
~~~~~~~~

This command is normally used inside of a block, wich is repeated by commands 
like ~#foreach~ and ~#loop~. ~#trigger~ defines an internal counter, which is 
increased for each loop iteration by ~1~. If a specified step is reached, the
enclosed template block will be executed.

..  source: html

    {{#trigger($steps, $start [, $reset])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $steps        | int       | x         | number of steps till trigger is activated     |
+---------------+-----------+-----------+-----------------------------------------------+
| $start        | int       | -         | optional step to start trigger counter at     |
+---------------+-----------+-----------+-----------------------------------------------+
| $reset        | mixed     | -         | optional variable may be used to reset the    |
|               |           |           | trigger. if the value of ~reset~ changes      |
|               |           |           | between two steps, the trigger will be        |
|               |           |           | resetted                                      |
+---------------+-----------+-----------+-----------------------------------------------+

Macros
------

Macros are special functions, which are resolved at compile time. The template engine
provides a macro for importing sub-templates. On compile time all main and
sub-templates will be merged together. This is especially useful for the css/javascript 
compressor described later in this documentation.

To make macros resolvable at compile time, they only accept static parameters:

*   constant
*   string
*   number
*   bool

No variables or method calls are allowed for parameters of a macro.

..  source: html

    <!-- allowed -->
    {{@import('static.html')}}
    
    <!-- not allowed -->
    {{@import($variable)}}

Besides the already provided macros, it's possible to register own macros.

@import
~~~~~~~

This macro is used to import sub-templates:

..  source: html

    {{@import('static.html')}}

@uniqid
~~~~~~~

Generates a unique ID at compile time. This is useful for example to force 
inclusion of a javascript/css multiple times and to prevent the optimizer to filter
multiple time inclusion of external javascript/css files.

..  source: html

    <script type="text/javascript" src="libsjs/lib.js?{{@uniqid()}}"></script>
    <script type="text/javascript" src="libsjs/lib.js?{{@uniqid()}}"></script>

Functions
---------

The template engine provides several built-in functions. Besides the built-in
functions it's possible to register additional functions that can be used in
a template.

The template has the following built-in functions:



Javascript & CSS compressor
---------------------------

The compressor is called after all macros and constants in a template are resolved
and the template was converted to PHP code. The compressor looks through the html
template and optimizes optimizes Javascript and CSS inclusion. The following tasks
are fulfilled:

*   optimizing includes reducing necessary HTTP requests
*   compressing Javascript and CSS

Optimizing HTTP Requests
~~~~~~~~~~~~~~~~~~~~~~~~

The compressor parses a HTML template and looks for multiple following

..  source: html

    <script type="text/javascript" src="..."></script>

and

..  source: html

    <link rel="stylesheet" type="text/css" href="..." />

tags. It will combine multiple files and rewrite the HTML template to reduce 
external file inclusion. For example:

_before:_

..  source: html

    <html>
        <link rel="stylesheet" type="text/css" href="default.css" />
        <link rel="stylesheet" type="text/css" href="hacks.css" />
        <script type="text/javascript" src="inc1.js"></script>
        <script type="text/javascript" src="inc2.js"></script>
        <script type="text/javascript" src="inc3.js"></script>
        <body>
            ...
            <script type="text/javascript" src="inc4.js"></script>
            <script type="text/javascript" src="inc5.js"></script>
            ...
        </body>
    </html>

_after:_

..  source: html

    <html>
        <link rel="stylesheet" type="text/css" href="combined.css" />
        <script type="text/javascript" src="combined1.js"></script>
        <body>
            ...
            <script type="text/javascript" src="combined2.js"></script>
            ...
        </body>
    </html>

In addition, each file will be included only once. This is very useful, when you
use sub-templates and wan't be sure, that every javascript required by the sub-
template is included and additionally make sure, that it was not already included
by an other template. The following example uses three templates -- main.html, 
sub1.html and sub2.html:

..  source: html

    <!-- main.html -->
    <html>
        <body>
            {{@import('sub1.html')}}
            {{@import('sub2.html')}}
        </body>
    </html>

    <!-- sub1.html -->
    <p>
        <script type="text/javascript" src="inc1.js"></script>
        <script type="text/javascript" src="inc2.js"></script>
        <script type="text/javascript" src="inc3.js"></script>
        ...
    </p>
    
    <!-- sub2.html -->
    <p>
        <script type="text/javascript" src="inc1.js"></script>
        <script type="text/javascript" src="inc2.js"></script>
        <script type="text/javascript" src="inc5.js"></script>
        ...
    </p>

After processing the above example using the compiler, you get one big template
main.html:

..  source: html

    <!-- main.html -->
    <html>
        <body>
            <p>
                <script type="text/javascript" src="inc1.js"></script>
                <script type="text/javascript" src="inc2.js"></script>
                <script type="text/javascript" src="inc3.js"></script>
                ...
            </p>
            <p>
                <script type="text/javascript" src="inc1.js"></script>
                <script type="text/javascript" src="inc2.js"></script>
                <script type="text/javascript" src="inc5.js"></script>
                ...
            </p>
        </body>
    </html>

The compressor will now optimize this and remove duplicate file inclusions:

..  source: html

    <!-- main.html -->
    <html>
        <body>
            <p>
                <script type="text/javascript" src="inc1.js"></script>
                <script type="text/javascript" src="inc2.js"></script>
                <script type="text/javascript" src="inc3.js"></script>
                ...
            </p>
            <p>
                <script type="text/javascript" src="inc5.js"></script>
                ...
            </p>
        </body>
    </html>

As the next step the optimizer will combine the inclusions, so there are actually
only two required includes left:

..  source: html

    <!-- main.html -->
    <html>
        <body>
            <p>
                <script type="text/javascript" src="combined.js"></script>
                ...
            </p>
            <p>
                <script type="text/javascript" src="inc5.js"></script>
                ...
            </p>
        </body>
    </html>

Sometimes it is required to include a javascript multiple times. This can be
achiefed simply by adding a unique identifier to the filename. For example: 

..  source: html

    <!-- main.html -->
    <html>
        <body>
            <p>
                <script type="text/javascript" src="inc1.js"></script>
                <script type="text/javascript" src="inc2.js"></script>
                <script type="text/javascript" src="inc3.js"></script>
                ...
            </p>
            <p>
                <script type="text/javascript" src="inc1.js?{{@uniqid()}}"></script>
                <script type="text/javascript" src="inc2.js?{{@uniqid()}}"></script>
                <script type="text/javascript" src="inc5.js"></script>
                ...
            </p>
        </body>
    </html>

~inc1.js~ and ~inc2.js~ from the second snippet will be treated as different
include files. So the resulting snippet after optimizing is:

..  source: html

    <!-- main.html -->
    <html>
        <body>
            <p>
                <script type="text/javascript" src="combined1.js"></script>
                ...
            </p>
            <p>
                <script type="text/javascript" src="combined2.js"></script>
                ...
            </p>
        </body>
    </html>

Compressing Javascript and CSS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The compressor uses YUI Compressor to compress javascript and CSS files.

