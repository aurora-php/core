Template Engine
===============

The octris framework provides an own template engine, which works independet of the structure of a template. It does
not matter, if the template is a simple text file or in HTML or XML format. 

The template engine converts templates to cacheable PHP code.


Template element syntax
-----------------------

Elements to be parsed by the template engine, have to be enclosed inside of {{...}}.

Template variables
------------------

Template variables are written in the form the following example, where ~varname~ is a fully
qualified name of an existing template variable:

..  source: html

    {{$varname}}
    {{$varname:first}}
    {{$varname:0:second}}
    ...

The examples above shows the access to values of simple variables and multidimensional arrays:

..  source: php

    $varname
    $varname["first"]
    $varname["0"]["second"]

_Example:_

..  source: html

    <html>
        <head>
            <title>{{$title}}</title>
        </head>

        <body>
            <p>
                <b>Hello {{$name:name}} {{$name:surname}}</b>
            </p>
            
            <p>
                Please <a href="{{$url}}">click</a> here!
            </p>
        </body>
    </html>

Template Constants
------------------

Template constants are written in the form the following example, where ~CONSTANT~ is a fully
qualified name of an existing template constant:

..  source: html

    {{%CONSTANT}}

The template engine defines the following constants:

Template block commands
-----------------------

A block encloses a part of a template and executes different actions of the enclosed template part:

..  source: html

    {{#block( parameter )}}
    ...
    {{#end}}

The template engine supports the following block commands:

#copy
~~~~~

This command copies a part of the template into an internal buffer. The command may be used to prevent duplicate
re-building of complex template parts. A HTML page navigation which should be displayed at the top and at the
bottom of the page, can be build the first time, copied and inserted as complete build snippet instead of 
re-building it at the bottom of the page. The copied template part may be accessed like a normal template variable.

_Copy block:_

..  source: html

    {{#copy($buffer)}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $buffer       | mixed     | x         | buffer variable to store copied content in    |
+---------------+-----------+-----------+-----------------------------------------------+

_Paste block:_

..  source: html

    {{$name}}

#cron
~~~~~

Publish a template part based on time.

..  source: html

    {{#cron($start [, $end])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $start        | mixed     | x         | start time as date/time string or unix        |
|               |           |           | timestamp                                     |
+---------------+-----------+-----------+-----------------------------------------------+
| $end          | mixed     | -         | optional end time as date/time string or unix |
|               |           |           | timestamp                                     |
+---------------+-----------+-----------+-----------------------------------------------+

The ~$end~ parameter is optional. If it's not specified, the block will never be hidden again. 
Note, that this is just triggered on server side. The block will only be displayed/hidden on a 
new request.

#cut
~~~~

The ~#cut~ block command is similar to ~#copy~, expect, that it cut's the rendered block into the buffer. The command
is useful to post-process rendered template parts. for example: a build stylesheet may be cut, compressed by a css-
compressor and than output in the template.

_Cut block:_

..  source: html

    {{#cut($buffer)}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $buffer       | mixed     | x         | buffer variable to store cut content in       |
+---------------+-----------+-----------+-----------------------------------------------+

_Process (and paste) block (example):_

..  source: html

    {{compactCSS($name)}}


#foreach
~~~~~~~~

This block command implements an array iterator. The enclosed block will be 
repeated for each element of the array specified as parameter. For each 
iteration a template variable of the specified name will be filled with the 
contents of the array item of the iteration.

..  source: html

    {{#foreach($item, $array [, $meta])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $item         | mixed     | x         | variable to store array item in               |
+---------------+-----------+-----------+-----------------------------------------------+
| $array        | array     | x         | array to iterate                              |
+---------------+-----------+-----------+-----------------------------------------------+
| $meta         | array     | -         | optional variable for metainformation         |
+---------------+-----------+-----------+-----------------------------------------------+

_Meta information:_

~#foreach~ adds the following keys/values to the optional ~$meta~ variable:

+---------------+-----------------------------------------------------------+
| Name          | Description                                               |
+===============+===========================================================+
| is_first      | is true, if it's the first iteration step                 |
+----------------+----------------------------------------------------------+
| is_last       | is true, if it's the last iteration step                  |
+---------------+-----------------------------------------------------------+
| key           | contents of key of iterartion step                        |
+---------------+-----------------------------------------------------------+
| pos           | number of iteration step starting with 0                  |
+---------------+-----------------------------------------------------------+
| count         | total number of items in array                            |
+---------------+-----------------------------------------------------------+

To access the properties in a template, just specify a third parameter, a variable
for the ~#foreach~ block:

..  source: html

    {{#foreach($item, $array, $meta)}}
        {{#if($meta:is_first)}}
            ...
        {{#end}}
    {{#end}}

#loop
~~~~~

Loop over the enclosed template block.

..  source: html

    {{#loop($step, $from, $to [, $meta])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $step         | int       | x         | current step of the loop                      |
+---------------+-----------+-----------+-----------------------------------------------+
| $from         | int       | x         | starting point of loop                        |
+---------------+-----------+-----------+-----------------------------------------------+
| $to           | int       | x         | ending point of loop                          |
+---------------+-----------+-----------+-----------------------------------------------+
| $meta         | array     | -         | optional variable for metainformation         |
+---------------+-----------+-----------+-----------------------------------------------+

It's allowed to specify ~from~ with a bigger number than ~to~.

_Meta information:_

~#loop~ adds the following keys/values to the optional ~$meta~ variable:

+---------------+-----------------------------------------------------------+
| Name          | Description                                               |
+===============+===========================================================+
| is_first      | is true, if it's the first iteration step                 |
+----------------+----------------------------------------------------------+
| is_last       | is true, if it's the last iteration step                  |
+---------------+-----------------------------------------------------------+
| key           | number of iteration step starting with 0                  |
+---------------+-----------------------------------------------------------+
| pos           | number of iteration step starting with 0                  |
+---------------+-----------------------------------------------------------+
| count         | total number of items in array                            |
+---------------+-----------------------------------------------------------+

~pos~ and ~key~ contain the same values. ~key~ is provided, to return the same meta
information for both iteration block types ~#foreach~ and ~#loop~.

To access the properties in a template, just specify a third parameter, a variable
for the ~#loop~ block:


..  source: html

    {{#loop($i, 0, 5, $meta)}}
        {{if($meta:is_first)}}
            ...
        {{#end}}
    {{#end}}

#onchange
~~~~~~~~~

This command is normally used inside of a block, wich is repeated by commands 
like ~#foreach~ and ~#loop~. With this command it's possible to observe the value
of a template variable. If the variable changes between _two_ calls of 
~#onchange~, the enclosed block will be executed.

..  source: html

    {{#onchange($value)}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $value        | mixed     | x         | variable to observe                           |
+---------------+-----------+-----------+-----------------------------------------------+

_Example:_

The example below demonstrates, how the variable ~$step~ is observed. If ~$step~
changes it's value, the enclosed block will be executed.

..  source: html

    {{#loop($step, 0, 5)}}
        ...
        {{#onchange($step)}}
            changed
        {{#end}}
    {{#end}}

#trigger
~~~~~~~~

This command is normally used inside of a block, wich is repeated by commands 
like ~#foreach~ and ~#loop~. ~#trigger~ defines an internal counter, which is 
increased for each loop iteration by ~1~. If a specified step is reached, the
enclosed template block will be executed.

..  source: html

    {{#trigger($steps, $start [, $reset])}}
    ...
    {{#end}}

_Parameter:_

+---------------+-----------+-----------+-----------------------------------------------+
| Name          | Type      | Mandatory | Description                                   |
+===============+=======================================================================+
| $steps        | int       | x         | number of steps till trigger is activated     |
+---------------+-----------+-----------+-----------------------------------------------+
| $start        | int       | -         | optional step to start trigger counter at     |
+---------------+-----------+-----------+-----------------------------------------------+
| $reset        | mixed     | -         | optional variable may be used to reset the    |
|               |           |           | trigger. if the value of ~reset~ changes      |
|               |           |           | between two steps, the trigger will be        |
|               |           |           | resetted                                      |
+---------------+-----------+-----------+-----------------------------------------------+

Macros
------

Macros are special functions, which are resolved at compile time. The template engine
provides a macro for importing sub-templates. On compile time all main and
sub-templates will be merged together. This is especially useful for the css/javascript 
compressor described later in this documentation.

To make macros resolvable at compile time, they only accept static parameters:

*   constant
*   string
*   number
*   bool

No variables or method calls are allowed for parameters of a macro.

..  source: html

    <!-- allowed -->
    {{@import('static.html')}}
    
    <!-- not allowed -->
    {{@import($variable)}}

Besides the already provided macros, it's possible to register own macros.

@import
~~~~~~~

This macro is used to import sub-templates:

..  source: html

    {{@import('static.html')}}

@uniqid
~~~~~~~

Generates a unique ID at compile time. This is useful for example to force 
inclusion of a javascript/css multiple times and to prevent the optimizer to filter
multiple time inclusion of external javascript/css files.

..  source: html

    <script type="libsjs/lib.js?{{@uniqid()}}"></script>
    <script type="libsjs/lib.js?{{@uniqid()}}"></script>

Functions
---------

The template engine provides several built-in functions. Besides the built-in
functions it's possible to register additional functions that can be used in
a template.

PHP functions
~~~~~~~~~~~~~

The following PHP functions are available in any template context. Have a
look at the official PHP documentation for further information of usage.

..  source: html

    html_entity_decode      addcslashes     ceil
    htmlentities            nl2br           round
    htmlspecialchars        strtoupper      
                            strtolower      
    json_decode             strcmp          
    json_encode             str_repeat      
    rawurldecode            str_replace     
    rawurlencode            sprintf         
                                            
    array_key_exists        trim
    isset                   ltrim
    count                   rtrim

~lima_app~ functions
~~~~~~~~~~~~~~~~~~~~

The following functions are only available, when template is accessed
using ~lima_app~'s getTemplate method. For further information see ~lima_app~
API documentation.

..  source: html

    getHtmlState
    
Built-in functions
~~~~~~~~~~~~~~~~~~

The template engine defines the following built-in and already registered
functions which are therefore available in any template context. See the 
API documentation of ~lima_tpl_sandbox~ for further information of how to
use them:

..  source: html

    dump



Registering own functions
~~~~~~~~~~~~~~~~~~~~~~~~~

It's possible to register own functions for useage in a template. This is
done in the application by the following PHP code:

..  source: php
    
    $template->registerMethod(&$object, $method);

_Example:_

..  source: php

    $template->registerMethod($this, 'formatString');

The function can be accessed from inside a template as already described:

..  source: html

    {{formatString()}}
    
The method ~registerMethod~ accepts an optional third parameter. A string where
it's possible to provide a custom name. This is useful for example, when there's
already a function with the same name registered.

Localization of templates
-------------------------

There's a built-in function for translating text messages:

..  source: html

    {{_('text message to translate')}}

It's possible to use so called ~inline~ functions to perform various
tasks for localization. There are functions for formatting numbers, 
dates etc. according to the current set localization-settings. The syntax
of these ~inline~ functions is as follows:

..  source: html

    {{_('[monf, _1] ([monf, _2] brutto)', 19.90, 21.29)}}

This would produce different output according to the local setting, for
example:

_en_US:_

..  source: html

    $19.90 ($21.29 brutto)
    
_de_DE:_

..  source: html

    19,90€ (21,29€ brutto)

An ~inline~ function is defined between the brackets '[' and ']'. The Parameters
for an ~inline~ function are seperated by ','. The first Parameter always defines
the name of the function, the following parameters are for providing values to the
function. The values can be either fixed ...

..  source: html

    {{_('[numf, 10.254]')}}
    
... or variable, specified by additional parameters to the translation function '_':

..  source: html

    {{_('[numf, _1]', 10.254)}}

In the latter case, the parameter '_1' defines the position of the translation
function's parameter to use as value for the ~inline~ function. This makes it 
possible to use multiple parameters for an ~inline~ function and even to use 
multiple ~inline~ functions inside of one message:

_Example:_

..  source: html

                +----------------------------+
                |           +----------------|------+
                |           |                |      |
                |           |                V      V
    {{_('[monf, _1] ([monf, _2] brutto)', 19.90, 21.29)}}

The example above visualizes which ~inline~ function's parameter uses which
localization function's parameter.

The template engine defines the following ~inline~ functions.

monf
~~~~

This functions purpose is the formatting of money values, including the 
currency sign of according to the local setting:

..  source: html

    {{_('[monf, _1]', $value)}}

_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| value         | float     | value to format as money                                  |
+---------------+-----------+-----------------------------------------------------------+

numf
~~~~

This function is somehow similar to monf. It's for localization numbers,
without adding currency symbol:

..  source: html

    {{_('[numf, _1, _2]', $value, $prec)}}

_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| value         | float     | value to format as number                                 |
+---------------+-----------+-----------------------------------------------------------+
| prec          | int       | (optional) precision                                      |
+---------------+-----------+-----------------------------------------------------------+

datef
~~~~~

This function's purpose is to format date, time and date/time values:

..  source: html

    {{_('[datef, _1, _2]', $value, $format)}}

_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| value         | float     | date/time value as unix timestamp or ISO date/time string |
+---------------+-----------+-----------------------------------------------------------+
| format        | int       | (optional) date/time format setting                       |
+---------------+-----------+-----------------------------------------------------------+

Default format is ~T_DATETIME_MEDIUM~. The following formatting constants are defined, 
in a template it's required to set the integer value instead of the PHP constant name:

+---------------------------------------+-------+
| Constant                              | Value |
+=======================================+=======+
| lima_type_datetime::T_DATE_FULL       | 1     |
+---------------------------------------+-------+
| lima_type_datetime::T_DATE_LONG       | 2     |
+---------------------------------------+-------+
| lima_type_datetime::T_DATE_MEDIUM     | 4     |
+---------------------------------------+-------+
| lima_type_datetime::T_DATE_SHORT      | 8     |
+---------------------------------------+-------+
|                                       |       |
+---------------------------------------+-------+
| lima_type_datetime::T_TIME_FULL       | 16    |
+---------------------------------------+-------+
| lima_type_datetime::T_TIME_LONG       | 32    |
+---------------------------------------+-------+
| lima_type_datetime::T_TIME_MEDIUM     | 64    |
+---------------------------------------+-------+
| lima_type_datetime::T_TIME_SHORT      | 128   |
+---------------------------------------+-------+
|                                       |       |
+---------------------------------------+-------+
| lima_type_datetime::T_DATETIME_FULL   | 17    |
+---------------------------------------+-------+
| lima_type_datetime::T_DATETIME_LONG   | 34    |
+---------------------------------------+-------+
| lima_type_datetime::T_DATETIME_MEDIUM | 68    |
+---------------------------------------+-------+
| lima_type_datetime::T_DATETIME_SHORT  | 136   |
+---------------------------------------+-------+

It's possible to generate a string of T_DATE_LONG in combination with 
T_TIME_SHORT by calculating the corresponding value using bit operators.

yesno
~~~~~

This function makes it possible to return two different values according to if
the first parameter of the function is (bool) ~true~ or (bool) ~false~:

..  source: html

    {{_('[yesno, _1, _2, _3]', $value, $first, $second)}}

_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| value         | boolean   | value to check                                            |
+---------------+-----------+-----------------------------------------------------------+
| first         | string    | message to output, if ~value~ is ~true~                   |
+---------------+-----------+-----------------------------------------------------------+
| second        | string    | message to output, if ~value~ is ~false~                  |
+---------------+-----------+-----------------------------------------------------------+

enum and quant
~~~~~~~~~~~~~~

This functions return one of three messages, according to the value that is 
specified as first parameter. The difference between ~quant~ and ~enum~ is,
that it's possible to output ~value~ together with the message when using
the function ~quant~. This can be achieved by placing ~%d~ somewhere in the
message.

..  source: html
    
    {{_('[enum, _1, _2, _3, _4]', $value, $first, $second, $third)}}
    {{_('[quant, _1, _2, _3, _4]', $value, $first, $second, $third)}}

_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| value         | float     | value to check                                            |
+---------------+-----------+-----------------------------------------------------------+
| first         | string    | message to output, if ~value~ == ~1~                      |
+---------------+-----------+-----------------------------------------------------------+
| second        | string    | message to output, if ~value~ != ~1~ and ~value~ != ~0~   |
+---------------+-----------+-----------------------------------------------------------+
| third         | string    | message to output, if ~value~ == ~0~                      |
+---------------+-----------+-----------------------------------------------------------+

_Example for ~enum~:_

..  source: html

    {{_('[enum, _1, one, many, no]', $value)}}
    
_Example for ~quant~:_

..  source: html

    {{_('[quant, _1, %d item, %d items, %d items]', $value)}}

comify
~~~~~~

This function accepts an array as first parameter and concatenates the items of 
the array except the last one using a custom seperator character. The last item
will be concatenated by a custom string:

..  source: html

    {{_('[comify, _1, _2, _3]', $list, $word, $sep)}}

_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| list          | array     | array of values to concatenate                            |
+---------------+-----------+-----------------------------------------------------------+
| word          | string    | the word to concatenate the last array item with the rest |
+---------------+-----------+-----------------------------------------------------------+
| sep           | string    | (optional) character to use as concatenator (default: ,)  |
+---------------+-----------+-----------------------------------------------------------+

_Example:_

..  source: html

    {{_('[comify, _1, and]', $array)}}
    
For an array with the items ...

..  source: php

    $value = array('one', 'two', 'three', 'four', 'five');
    
... this would produce the following output:

..  source: html

    one, two, three, four and five
    
gender
~~~~~~

This function is used to output different messages according to a specified 
gender:

..  source: html

    {{_('[gender, _1, _2, _3, _4]', $val, $undefined, $male, $female)}}
    
_Parameter:_

+---------------+-----------+-----------------------------------------------------------+
| Name          | Type      | Description                                               |
+===============+=======================================================================+
| value         | mixed     | gender                                                    |   
+---------------+-----------+-----------------------------------------------------------+
| undefined     | string    | message to output, if gender is not identifiable          |
+---------------+-----------+-----------------------------------------------------------+
| male          | string    | message to output, if gender is male                      |
+---------------+-----------+-----------------------------------------------------------+
| female        | string    | message to output, if gender is female                    |
+---------------+-----------+-----------------------------------------------------------+

The following is a lookup table of values to the corresponding gender:

+---------------+-------------------+
| Gender        | Values            |
+===============+===+===+===+===+===+
| *male*        | M | m | 1 |   |   |
+---------------+---+---+---+---+---+
| *female*      | F | f | W | w | 2 |
+---------------+-----------+---+---+
| *undefined*   | N | n | 0 |   |   |
+---------------+-----------+---+---+

Template Engine
===============

Block commands
--------------

#if(...)
~~~~~~~~

#foreach()
~~~~~~~~~~


Math functions
--------------

add
~~~

Add two or more parameters.

..  source: php

    add



*   context awareness: html / xml, javascript, text ...

    this is needed to apply auto-escaping and context-aware escaping to values:
    
    *   http://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html

*   variable scopes for template

    tpl::setValue(name, value, scope = '')

    class ... {
        $tpl->setValue('name', 'value', $this);
    }

    setvalue expects string or object of instance 'page' as 3rd paramter. extracts page name of class name of object.
    
    access in template:
    
    {{$scope:variable}}
    
    questions:
    
    *   how can we handle nested scopes and the possibility to leave name of scope away when trying to fetch variable 
        in this way in template?

*   Every Variable in the Template is an object. The following Objects
    are available:
    
    *   String
    *   Number
    *   Money
    *   Collection
    
    The template variable types are inherited from the core variable types.

Syntax
------

..  source: plain

    {{$variable}}                   // casted to string

    {{$object->property}}           // object property casted to string

    ::($variable->default('...'))     // string object

Blocks
------

..  source: plain
    
    :(foreach())
    :(end)
    
    :‚‚IF(...)}}
    {{ELSEIF(...)}}
    {{END}}

    {{IF(...)}}
    {{ELSEIF(...)}}
    {{END}}


compressor 

- compressor optimizes javascript/css inclusion. the same file will only be 
  included one time. to force including multiple times, just add a request 
  parameter:
  
  <script src="...?{{@uniqid()}}"
